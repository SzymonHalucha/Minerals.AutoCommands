namespace Minerals.AutoCommands.Generators
{
    [Generator]
    public class CommandParserGenerator : IIncrementalGenerator
    {
        public void Initialize(IncrementalGeneratorInitializationContext context)
        {
            var arguments = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                "Minerals.AutoCommands.Attributes.CommandArgumentAttribute",
                static (x, _) => true, //TODO: Optimize this for value types that matters
                static (x, _) => x
            );

            var statements = context.SyntaxProvider.ForAttributeWithMetadataName
            (
                "Minerals.AutoCommands.Attributes.CommandStatementAttribute",
                static (x, _) => true, //TODO: Optimize this for value types that matters
                static (x, _) => x
            );

            var combined = statements.Collect().Combine(arguments.Collect());
            context.RegisterSourceOutput(combined, static (ctx, element) =>
            {
                string fileName = $"CommandParser.g.cs";
                ctx.AddSource(fileName, BuildCommandParserPartialClass
                (
                    element.Left,
                    element.Right
                ));
            });
        }

        private static SourceText BuildCommandParserPartialClass
        (
            IEnumerable<GeneratorAttributeSyntaxContext> statements,
            IEnumerable<GeneratorAttributeSyntaxContext> arguments
        )
        {
            var builder = new CodeBuilder();
            builder.AddAutoGeneratedHeader(Assembly.GetExecutingAssembly());
            AddAllNamespacesAsUsings(builder, statements, arguments);
            builder.NewLine();

            builder.WriteLine("namespace Minerals.AutoCommands");
            builder.OpenBlock();

            builder.AddAutoGeneratedAttributes(typeof(ClassDeclarationSyntax));
            builder.WriteLine("public static class CommandParser");
            builder.OpenBlock();

            GenerateParseMethod(builder, statements, arguments);

            builder.CloseAllBlocks();
            return SourceText.From(builder.ToString(), Encoding.UTF8);
        }

        private static void AddAllNamespacesAsUsings
        (
            CodeBuilder builder,
            IEnumerable<GeneratorAttributeSyntaxContext> statements,
            IEnumerable<GeneratorAttributeSyntaxContext> arguments
        )
        {
            var statementsNs = statements.Select(x => x.TargetNode.GetNamespace()?.Name.ToString());
            var argumentsNs = arguments.Select(x => x.TargetNode.GetNamespace()?.Name.ToString());
            var allNamespaces = statementsNs.Concat(argumentsNs).Distinct();
            foreach (var ns in allNamespaces)
            {
                if (ns != null)
                {
                    builder.WriteLine("using ").Write(ns).Write(";");
                }
            }
        }

        private static void GenerateParseMethod
        (
            CodeBuilder builder,
            IEnumerable<GeneratorAttributeSyntaxContext> statements,
            IEnumerable<GeneratorAttributeSyntaxContext> arguments
        )
        {
            builder.WriteLine("public static global::Minerals.AutoCommands.Interfaces.ICommand Parse(string arg, global::System.StringComparison comparison)")
                .OpenBlock();

            if (statements.Any() || arguments.Any())
            {
                GenerateConditions(builder, statements, true);
                GenerateConditions(builder, arguments, false);
                builder.WriteLine("else return null;");
            }
            else
            {
                builder.WriteLine("return null;");
            }

            builder.CloseBlock();
        }

        private static void GenerateConditions(CodeBuilder builder, IEnumerable<GeneratorAttributeSyntaxContext> commands, bool first)
        {
            bool isFirst = first;
            foreach (var command in commands)
            {
                foreach (var attribute in command.Attributes)
                {
                    foreach (var argument in attribute.ConstructorArguments.First().Values)
                    {
                        if (isFirst)
                        {
                            builder.NewLine();
                            isFirst = false;
                        }
                        else
                        {
                            builder.WriteLine("else ");
                        }
                        builder.Write(@"if (arg.Equals(""")
                            .Write(argument.Value!.ToString())
                            .Write(@""", comparison)) return (global::Minerals.AutoCommands.Interfaces.ICommand)new ")
                            .Write(((ClassDeclarationSyntax)command.TargetNode).Identifier.ValueText)
                            .Write(@"();");
                    }
                }
            }
        }
    }
}